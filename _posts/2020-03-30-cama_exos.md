---
title:          "CAMA : ma01 et ma02 - Exercices"
date:           2020-03-30 11:00
categories:     [S6, Shannon, CAMA]
tags:           [S6, CAMA, Shannon]
description: Exercices des notebooks 1 et 3
---
Lien de la [note Hackmd](https://hackmd.io/@lemasymasa/BkyoLgiyP)
# Exercice 1.1
√âcrire sous forme d'un produit matriciel la sym√©trie axiale par rapport √† un axe qui ne passe pas par (0,0). On prendra l'axe qui passe par (2,0) et qui a un angle de œÄ/3 par rapport √† l'horizontale.

Est-ce un automorphisme orthogonal ? Le montrer.

<details markdown="1">
<summary>Solution</summary>
``` python
def R3(Œ±):
    return np.array([[np.cos(Œ±), -np.sin(Œ±), 0], [np.sin(Œ±), np.cos(Œ±), 0], [0, 0, 1]])

Sx3 = np.array([[1,0,0], [0,-1,0], [0,0,1]])

def T(v):  # translation of v
    T = np.identity(3)
    T[0:2,2] = v
    return T

Œ∏ = np.pi / 3
a = np.array([2,0])

S =  T(a) @ R3(Œ∏) @ Sx3 @ R3(-Œ∏) @ T(-a)
print("Matrix of symmetry:\n", S)

shape2 = S @ shape1_3d

plt.plot(shape1[0], shape1[1], ":")
plt.plot(shape2[0], shape2[1])
plt.plot([a[0]-3*np.cos(Œ∏),a[0]+np.cos(Œ∏)],[a[1]-3*np.sin(Œ∏),a[1]+np.sin(Œ∏)], "-.")  # axe de sym√©trie
plt.axis('equal');
```
```
Matrix of symmetry:
 [[-0.5    0.866  3.   ]
 [ 0.866  0.5   -1.732]
 [ 0.     0.     1.   ]]
```
![](https://i.imgur.com/r0OKNQK.png)
``` python
# Ce n'est pas un automorphisme orthogonal car S n'est pas orthogonale :

S @ S.T
```
```
array([[10.   , -5.196,  3.   ],
       [-5.196,  4.   , -1.732],
       [ 3.   , -1.732,  1.   ]])
```
</details>

# Exercice 3.1 (rotation de la cam√©ra autour de son axe)
On a indiqu√© que  ùúÉ  est l'angle que la cam√©ra fait par rapport √† l'horizontal (√† supposer que dans le monde r√©el un des axes est la verticale). Ajouter √† toutes les transformations la possibilit√© de faire tourner la cam√©ra sur son axe principal.

<details markdown="1">
<summary>Solution</summary>
``` python
# on fait une simple matrice de rotation autour de z apr√®s √™tre dans le rep√®re de la cam√©ra

roll = lambda t:  np.array([[np.cos(t), -np.sin(t), 0, 0], [np.sin(t), np.cos(t), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])
```
``` python
view(F(2.3) @ roll(np.pi/4) @ R @ T(c))
```
![](https://i.imgur.com/iZriqMu.png)
</details>

# Exercice 3.2
D√©finir la direction dans laquelle regarde la cam√©ra avec un vecteur et non 2 angles de rotation. R√©digez pour expliquer vos calculs.
``` python
direction = [1,1,0]  # √† gauche √† 45 degr√©
```
<details markdown="1">
<summary>Solution</summary>
On a vu que dans la monde 3D r√©el la direction initiale de la cam√©ra est x.

Il faut transformer la nouvelle direction qu'on nous donne pour la cam√©ra en 2 angles de rotation ce qui donnera nos 2 matrices de rotation. On calcule les angles en fonction de la direction donn√©e grace aux formules de trigonom√©trie qu'on retrouve sur le cercle unit√©.

En 2D on a :
* $x=\cos(\alpha)$ 
* $y=\sin(\alpha)$ 

Donc si on a la direction (x,y) cela veut dire que l'angle qui nous int√©resse est  $\alpha=\arccos(x)$  mais ATTENTION cela n'est juste que si la direction est de norme = 1. Aussi on prend le ratio entre x et y qui est √©gale au ratio des valeurs norm√©es. Ainsi
$$
\alpha=\arctan(y/x)
$$
En 3D on doit se rapportee au cas 2D qui diff√©re suivant qu'on cherche l'angle vertical ou horizontal.

La rotation horizontale se fait dans le plan [x,y] :

* $x=\cos(\psi)$ 
* $y=\sin(\psi)$ 

et donc
$$
\psi=\arctan(y/x)
$$
La rotation verticale se fait dans le plan [x+y, z] avec $\psi\in[‚àí\pi/2,\pi/2]$
* $||x+y||=cos(\phi)$
* $z=\sin(\phi)$

et donc
$$
\phi=\arctan(z/||x+y||)
$$
``` python
def D(direction):
    if len(direction) == 2: # 2 angles
        ah = direction[0]
        av = direction[1]
    else:                   # on convertit la direction en angle
        norm = np.sqrt(direction[0]**2 + direction[1]**2)
        if norm == 0: # alors c'est vertical
            ah = 0
            av = 1
        else:
            av = np.arctan(direction[2]/norm)
        if direction[0] == 0:
            if direction[1] != 0:
                ah = np.sign(direction[1]) * np.pi/2
        else:
            ah = np.arctan(direction[1]/direction[0])
    print(ah, av)    
    if type(ah) == int:
        ah = ah * 2 * np.pi / 360
        av = av * 2 * np.pi / 360
    rh = np.array([[np.cos(ah), -np.sin(ah), 0, 0], [np.sin(ah), np.cos(ah), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]])
    rv = np.array([[np.cos(av), 0, np.sin(av), 0], [0, 1, 0, 0], [-np.sin(av), 0, np.cos(av), 0], [0, 0, 0, 1]])
    return rv @ rh
```
``` python
view(F(2.3) @ R @ D([1,1,0]) @ T(c))
```
```
0.7853981633974483 0.0
```
![](https://i.imgur.com/lR8yMWH.png)
</details>